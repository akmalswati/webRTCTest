<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Web Client</title>
  <script src="https://cdn.socket.io/4.8.0/socket.io.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    video { width: 45%; border: 1px solid #ccc; margin: 5px; }
    #videos { display: none; }
  </style>
</head>
<body>
  <h1>WebRTC Web â†” Web</h1>

  <div id="join">
    <label>
      Server URL:
      <input id="serverUrl" value="https://webrtctest-pa82.onrender.com/" style="width: 250px;">
    </label>
    <br><br>
    <label>
      Room ID:
      <input id="roomId" value="room1">
    </label>
    <br><br>
    <label>
      User ID:
      <input id="userId" value="webuser1">
    </label>
    <br><br>
    <button id="joinBtn">Join Room</button>
    <div id="status" style="margin-top: 10px; color: #555;"></div>
  </div>

  <div id="videos">
    <h3>Local</h3>
    <video id="localVideo" autoplay playsinline muted></video>
    <h3>Remote</h3>
    <video id="remoteVideo" autoplay playsinline></video>
    <br><br>
    <button id="hangupBtn">Hang Up</button>
  </div>

  <script>
    let socket;
    let pc;
    let localStream;
    let remoteStream;
    let peerSocketId = null;
    let isInitiator = false;

    const configuration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
      ]
    };

    const joinBtn = document.getElementById('joinBtn');
    const serverUrlInput = document.getElementById('serverUrl');
    const roomIdInput = document.getElementById('roomId');
    const userIdInput = document.getElementById('userId');
    const statusEl = document.getElementById('status');
    const videosDiv = document.getElementById('videos');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const hangupBtn = document.getElementById('hangupBtn');

    function log(msg) {
      console.log(msg);
      statusEl.textContent = msg;
    }

    joinBtn.onclick = async () => {
      const serverUrl = serverUrlInput.value.trim();
      const roomId = roomIdInput.value.trim();
      const userId = userIdInput.value.trim();

      if (!serverUrl || !roomId || !userId) {
        alert('Please fill all fields');
        return;
      }

      try {
        log('Connecting to signaling server...');
        socket = io(serverUrl, { transports: ['websocket'] });

        socket.on('connect', async () => {
          log(`Connected as socket ${socket.id}, joining room ${roomId}...`);

          // Get local media immediately
          await setupLocalMedia();

          // Join signaling room
          socket.emit('join', { roomId, userId });
        });

        registerSocketHandlers();
      } catch (err) {
        console.error(err);
        log('Error: ' + err.message);
      }
    };

    async function setupLocalMedia() {
      if (localStream) return; // already done

      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        localVideo.srcObject = localStream;
        videosDiv.style.display = 'block';
        log('Got local media');
      } catch (err) {
        console.error('getUserMedia error', err);
        alert('Could not access camera/mic: ' + err.message);
        throw err;
      }
    }

    function createPeerConnection() {
      pc = new RTCPeerConnection(configuration);

      // Add local tracks
      localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
      });

      pc.onicecandidate = (event) => {
        if (event.candidate && peerSocketId) {
          socket.emit('ice-candidate', {
            candidate: {
              candidate: event.candidate.candidate,
              sdpMid: event.candidate.sdpMid,
              sdpMLineIndex: event.candidate.sdpMLineIndex
            },
            to: peerSocketId
          });
        }
      };

      pc.ontrack = (event) => {
        if (!remoteStream) {
          remoteStream = new MediaStream();
          remoteVideo.srcObject = remoteStream;
        }
        remoteStream.addTrack(event.track);
      };

      pc.onconnectionstatechange = () => {
        console.log('Connection state:', pc.connectionState);
        if (pc.connectionState === 'connected') {
          log('Peers connected');
        }
        if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
          log('Peer disconnected');
        }
      };
    }

    function registerSocketHandlers() {
      socket.on('joined-room', (data) => {
        log(`Joined room ${data.roomId}. Other participants: ${data.existingCount}`);
      });

      socket.on('room-full', ({ roomId }) => {
        log(`Room ${roomId} is full`);
      });

      socket.on('ready', async ({ peerSocketId: peerId, isInitiator: initiator }) => {
        log(`Room ready. Peer: ${peerId}. Initiator: ${initiator}`);
        peerSocketId = peerId;
        isInitiator = initiator;

        createPeerConnection();

        if (isInitiator) {
          // We start the offer
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit('offer', {
            sdp: offer,
            to: peerSocketId
          });
          log('Sent offer');
        } else {
          log('Waiting for offer...');
        }
      });

      socket.on('offer', async ({ sdp, from }) => {
        log('Received offer');
        peerSocketId = from;
        if (!pc) createPeerConnection();

        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        socket.emit('answer', {
          sdp: answer,
          to: from
        });
        log('Sent answer');
      });

      socket.on('answer', async ({ sdp, from }) => {
        log('Received answer');
        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
      });

      socket.on('ice-candidate', async ({ candidate, from }) => {
        if (!pc) return;
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
          console.error('Error adding ICE candidate', err);
        }
      });

      socket.on('peer-left', ({ socketId, userId }) => {
        log(`Peer left: ${userId || socketId}`);
        cleanupCall();
      });

      socket.on('disconnect', () => {
        log('Disconnected from signaling server');
        cleanupCall();
      });
    }

    function cleanupCall() {
      if (pc) {
        pc.close();
        pc = null;
      }
      if (remoteStream) {
        remoteStream.getTracks().forEach(t => t.stop());
        remoteStream = null;
        remoteVideo.srcObject = null;
      }
    }

    hangupBtn.onclick = () => {
      if (socket) socket.disconnect();
      cleanupCall();
      log('Hung up');
    };
  </script>
</body>
</html>
